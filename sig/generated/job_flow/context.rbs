# Generated from lib/job_flow/context.rb with RBS::Inline

module JobFlow
  class Context
    # rubocop:disable Metrics/ClassLength
    attr_reader workflow: Workflow

    attr_reader arguments: Arguments

    attr_reader output: Output

    attr_reader job_status: JobStatus

    # :  (Hash[Symbol, untyped]) -> Context
    def self.from_hash: (Hash[Symbol, untyped]) -> Context

    # :  (Hash[String, untyped]) -> Context
    def self.deserialize: (Hash[String, untyped]) -> Context

    # :  (
    #      workflow: Workflow,
    #      arguments: Arguments,
    #      task_context: TaskContext,
    #      output: Output,
    #      job_status: JobStatus,
    #      ?job: DSL?
    #    ) -> void
    def initialize: (workflow: Workflow, arguments: Arguments, task_context: TaskContext, output: Output, job_status: JobStatus, ?job: DSL?) -> void

    # :  () -> Hash[String, untyped]
    def serialize: () -> Hash[String, untyped]

    # :  (Hash[Symbol, untyped]) -> Context
    def _update_arguments: (Hash[Symbol, untyped]) -> Context

    # :  (DSL) -> void
    def _job=: (DSL) -> void

    # :  () -> DSL?
    def _job: () -> DSL?

    # :  () -> String
    def job_id: () -> String

    # :  () -> bool
    def sub_job?: () -> bool

    # :  () -> String?
    def concurrency_key: () -> String?

    # :  (Task) -> Enumerator[Context]
    def _with_each_value: (Task) -> Enumerator[Context]

    # :  () { () -> void } -> void
    def _with_task_throttle: () { () -> void } -> void

    # :  (limit: Integer, ?key: String?, ?ttl: Integer) { () -> void } -> void
    def throttle: (limit: Integer, ?key: String?, ?ttl: Integer) { () -> void } -> void

    # Instruments a custom operation with ActiveSupport::Notifications.
    # This creates a span in OpenTelemetry (if enabled) and logs the event.
    #
    # @example Basic usage
    #   ```ruby
    #   ctx.instrument("api_call", endpoint: "/users") do
    #     HTTP.get("https://api.example.com/users")
    #   end
    #   ```
    #
    # @example With automatic operation name
    #   ```ruby
    #   ctx.instrument do
    #     # operation name defaults to "custom"
    #     expensive_operation()
    #   end
    #   ```
    #
    # :  (?String, **untyped) { () -> untyped } -> untyped
    def instrument: (?String, **untyped) { () -> untyped } -> untyped

    # :  () -> untyped
    def each_value: () -> untyped

    # :  () -> TaskOutput?
    def each_task_output: () -> TaskOutput?

    # :  () -> TaskContext
    def _task_context: () -> TaskContext

    # :  (TaskOutput) -> void
    def _add_task_output: (TaskOutput) -> void

    # :  () -> void
    def _load_parent_task_output: () -> void

    private

    attr_accessor job: DSL?

    attr_writer workflow: Workflow

    attr_writer arguments: Arguments

    attr_writer output: Output

    attr_writer job_status: JobStatus

    attr_accessor task_context: TaskContext

    attr_accessor enabled_with_each_value: bool

    attr_accessor throttle_index: Integer

    # :  () -> String
    def parent_job_id: () -> String

    # :  () -> Hash[String, untyped]
    def serialize_for_job: () -> Hash[String, untyped]

    # :  () -> Hash[String, untyped]
    def serialize_for_sub_job: () -> Hash[String, untyped]

    # :  (Task, Enumerator::Yielder) -> void
    def with_task_context: (Task, Enumerator::Yielder) -> void

    # :  (Task) -> void
    def reset_task_context_if_task_changed: (Task) -> void

    # :  (Task) { (untyped, Integer) -> void } -> void
    def with_each_index_and_value: (Task) { (untyped, Integer) -> void } -> void

    # :  () { () -> void } -> void
    def with_task_timeout: () { () -> void } -> void

    # :  (Task) { (Integer) -> void } -> void
    def with_retry: (Task) { (Integer) -> void } -> void

    # :  (Task, TaskRetry, Integer, StandardError) -> void
    def wait_next_retry: (Task, TaskRetry, Integer, StandardError) -> void
  end
end

# Generated from lib/job_flow/instrumentation.rb with RBS::Inline

module JobFlow
  # Instrumentation provides ActiveSupport::Notifications-based event instrumentation for JobFlow workflows and tasks.
  #
  # @example Subscribing to events
  #   ```ruby
  #   ActiveSupport::Notifications.subscribe("task.start.job_flow") do |name, start, finish, id, payload|
  #     puts "Task #{payload[:task_name]} started"
  #   end
  #   ```
  module Instrumentation
    NAMESPACE: ::String

    module Events
      WORKFLOW: untyped

      WORKFLOW_START: untyped

      WORKFLOW_COMPLETE: untyped

      TASK: untyped

      TASK_START: untyped

      TASK_COMPLETE: untyped

      TASK_ERROR: untyped

      TASK_SKIP: untyped

      TASK_ENQUEUE: untyped

      TASK_RETRY: untyped

      THROTTLE_ACQUIRE: untyped

      THROTTLE_ACQUIRE_START: untyped

      THROTTLE_ACQUIRE_COMPLETE: untyped

      THROTTLE_RELEASE: untyped

      DEPENDENT_WAIT: untyped

      DEPENDENT_WAIT_START: untyped

      DEPENDENT_WAIT_COMPLETE: untyped

      CUSTOM: untyped
    end

    # :  (DSL) { () -> untyped } -> untyped
    def self.instrument_workflow: (DSL) { () -> untyped } -> untyped

    # :  (DSL, Task, Context) { () -> untyped } -> untyped
    def self.instrument_task: (DSL, Task, Context) { () -> untyped } -> untyped

    # :  (DSL, Task, String) -> void
    def self.notify_task_skip: (DSL, Task, String) -> void

    # :  (DSL, Task, Integer) -> void
    def self.notify_task_enqueue: (DSL, Task, Integer) -> void

    # :  (Task, Context, String, Integer, Float, StandardError) -> void
    def self.notify_task_retry: (Task, Context, String, Integer, Float, StandardError) -> void

    # :  (DSL, Task) { () -> untyped } -> untyped
    def self.instrument_dependent_wait: (DSL, Task) { () -> untyped } -> untyped

    # :  (Semaphore) { () -> untyped } -> untyped
    def self.instrument_throttle: (Semaphore) { () -> untyped } -> untyped

    # :  (Semaphore) -> void
    def self.notify_throttle_release: (Semaphore) -> void

    # :  (String, Hash[Symbol, untyped]) { () -> untyped } -> untyped
    def self.instrument_custom: (String, Hash[Symbol, untyped]) { () -> untyped } -> untyped

    # :  (String, Hash[Symbol, untyped]) ?{ () -> untyped } -> untyped
    private def self.instrument: (String, Hash[Symbol, untyped]) ?{ () -> untyped } -> untyped

    # :  (DSL) -> Hash[Symbol, untyped]
    private def self.build_workflow_payload: (DSL) -> Hash[Symbol, untyped]

    # :  (DSL, Task, Context) -> Hash[Symbol, untyped]
    private def self.build_task_payload: (DSL, Task, Context) -> Hash[Symbol, untyped]

    # :  (DSL, Task, String) -> Hash[Symbol, untyped]
    private def self.build_task_skip_payload: (DSL, Task, String) -> Hash[Symbol, untyped]

    # :  (DSL, Task, Integer) -> Hash[Symbol, untyped]
    private def self.build_task_enqueue_payload: (DSL, Task, Integer) -> Hash[Symbol, untyped]

    # :  (Task, Context, String, Integer, Float, StandardError) -> Hash[Symbol, untyped]
    private def self.build_task_retry_payload: (Task, Context, String, Integer, Float, StandardError) -> Hash[Symbol, untyped]

    # :  (DSL, Task) -> Hash[Symbol, untyped]
    private def self.build_dependent_payload: (DSL, Task) -> Hash[Symbol, untyped]

    # :  (Semaphore) -> Hash[Symbol, untyped]
    private def self.build_throttle_payload: (Semaphore) -> Hash[Symbol, untyped]
  end
end
